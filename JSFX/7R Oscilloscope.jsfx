version: 1.2
Author: 7thResonance
desc:7R Oscilloscope


in_pin:left input
in_pin:right input
options:no_meter



@init
gfx_ext_flags |= 0x100 | 0x200;
gfx_ext_retina == 0 ? gfx_ext_retina = 1;
ext_nodenorm=1;
recpos=0;
gfx_clear=-1;
g_maxlen_ms=5000;
histsize=((srate*2.0*g_maxlen_ms/1000)|0)*2;

// Initialize smoothing variables
smooth_factor = 1; // Smoothing disabled
prev_left = 0;
prev_right = 0;
last_norm_factor = 1;




// Zero-crossing pitch detection parameters (for 40-5000 Hz)
zc_bufsize = max(2048, (srate/40)|0); // buffer covers down to 40 Hz
zc_buf = 0;
zc_period = 0;
zc_pitch = 0;
zc_last = 0;
zc_counter = 0;
zc_update_interval = 1; // update every block for fastest response
// helper buffers for autocorrelation (allocated as empty arrays)
dec_buf = 0;
Rarr = 0;

// UI defaults: retrig ascending, range auto, length auto
view_retrig = 2; // ascending
view_maxdb = 0; // auto range (0dB)
view_msec = 0; // auto length (period-locked)

@block 
g_last_wr = time_precise();


@sample
// No sample cutting: write raw faded values equal to the samples (no hard suppression)
// Keep prev_* in sync but do not force samples to zero
fade_left = spl0;
fade_right = spl1;
prev_left = fade_left;
prev_right = fade_right;
// Optionally disable auto-normalisation when the raw audio is very small (e.g. -90 dB):
// if the raw channel level is below disable_lin, write the raw sum into the scope buffer
// and let the waveform shrink naturally; otherwise use the faded/gated values.
disable_db = -55; // dB threshold below which auto-normalise is disabled
disable_lin = exp(disable_db*(log(10)/20));
// compute the raw channel magnitude to decide whether to hold normalization
raw_max = abs(spl0) > abs(spl1) ? abs(spl0) : abs(spl1);
disable_norm = raw_max < disable_lin ? 1 : 0;
// Feature 1: Sum L+R for display using faded values (does not affect audio output)
// Use the fade_* values so the gate/expander actually suppresses tiny residuals in the scope
sum = (fade_left + fade_right) * 0.5;
recpos[0]=sum;
recpos[1]=sum;
recpos = (recpos+2) >= histsize ? 0 : (recpos+2);


// --- Zero-crossing pitch detection for full range (40-5000 Hz) ---
zc_buf[zc_last] = sum;
zc_last += 1;

zc_last >= zc_bufsize ? (
  zc_last = 0;
  zc_counter += 1;
  zc_counter >= zc_update_interval ? (
    zc_counter = 0;
    // Check peak in buffer
    peak_zc = 0;
    i = 0;
    loop(zc_bufsize,
      absval = abs(zc_buf[i]);
      absval > peak_zc ? peak_zc = absval;
      i += 1;
    );
    // Only update period if peak is above threshold
    zc_threshold = 0.001; // -60 dB linear
    peak_zc > zc_threshold ? (
      // Fractional zero-crossing detection using linear interpolation
      // small DC removal to reduce bias
      mean = 0; i = 0;
      loop(zc_bufsize, mean += zc_buf[i]; i += 1;);
      mean = mean / zc_bufsize;

      crossings = 0;
      last_sign = (zc_buf[0] - mean) >= 0 ? 1 : -1;
      i = 1;
      first_cross_pos = -1;
      last_cross_pos = -1;
      loop(zc_bufsize-1,
        prev = zc_buf[i-1] - mean;
        curr = zc_buf[i] - mean;
        s = curr >= 0 ? 1 : -1;
        s != last_sign ? (
          // compute fractional crossing between i-1 and i
          denom = abs(prev) + abs(curr);
          frac = denom > 0 ? (abs(prev) / denom) : 0.5;
          cross_pos = (i-1) + frac;
          crossings += 1;
          last_sign = s;
          first_cross_pos < 0 ? first_cross_pos = cross_pos;
          last_cross_pos = cross_pos;
        );
        i += 1;
      );
      // Estimate period and pitch from fractional crossing positions
      periods = crossings / 2.0;
      (periods >= 1 && last_cross_pos > first_cross_pos) ? (
        avg_period = (last_cross_pos - first_cross_pos) / periods;
        zc_period = avg_period;
        zc_pitch = avg_period > 0 ? srate / avg_period : 0;
      );
    );
    // If peak is below threshold, do not update zc_period
  );
);


@gfx 640 400
small_mode = gfx_w<200*gfx_ext_retina || gfx_h<100*gfx_ext_retina;
gfx_ext_retina>1 ? gfx_setfont(1,"Arial",16*gfx_ext_retina,'b') : gfx_setfont(0);

gfx_getchar(); // request mouse_cap to be set even when mouse button not down



// --- Use zero-crossing period for auto window (display follows scaled pitch) ---
zc_period > 0 ? (
  // make displayed period consistent with the displayed (reduced) pitch
  zc_period_display = zc_period / pitch_scale;
  view_msec = zc_period_display*1000/srate;
) : (
  view_msec = 100; // fallback default
);
viewsize_spls = (view_msec*srate*0.001)|0;

function color1() ( gfx_r=0; gfx_g=0; gfx_b=1.0; );
function color2() ( gfx_r=0; gfx_g=0; gfx_b=1.0; );


function format_time_msec(a) (
  abs(a) < 1000 ? 
    sprintf(#,"%.02fms",a + 0.005) : 
    sprintf(#,"%.02fs",a*0.001 + 0.005);
);

function format_time_msec_hz(b)(
  b > 1 ? 
    b > 250 ? 
      sprintf(#,small_mode ? "%.1fs":"%.02fs",b*0.001 + 0.005) : 
    sprintf(#,small_mode ? "%dHz":"%d Hz",1000/b+0.5) : 
  sprintf(#,small_mode?"%.1fk":"%.1f kHz",1/b + 0.05); 
); 

// All mouse wheel and slider automation code removed for static UI

rdoffs = view_retrig >= 1.0 ? 0 : max(0,max(srate*1/20, samplesblock*2) - (time_precise() - g_last_wr)*srate)|0;
recpos_u = recpos - rdoffs*2;
recpos_u < 0 ? recpos_u += histsize;


view_msec_rounded = view_msec;
viewsize_spls = (view_msec*srate*0.001)|0;
viewadv = gfx_w/viewsize_spls;
// when zoomed out, adjust interval so that each peak represents a discrete number of samples
viewadvn = floor(1/viewadv + 0.5);
viewadvn > 8 ? (
  viewsize_spls = viewadvn * gfx_w;
  viewadv = 1/viewadvn;
  view_msec_rounded = viewsize_spls*1000/srate;
  recpos_u = floor(recpos_u/(viewadvn*2))*viewadvn*2;
) : viewadvn=0;

// always update view
view_maxdb_last = view_maxdb;
recpos_u_last = recpos_u;
old_w=gfx_w; old_h=gfx_h;

// Clamp view_maxdb to [-60, 0] dB range
view_maxdb < -60 ? view_maxdb = -60;
view_maxdb > 0 ? view_maxdb = 0;

gfx_r=gfx_g=gfx_b=0; gfx_a=1;
gfx_x=gfx_y=0;
gfx_rectto(gfx_w,gfx_h);

// Debug overlay: show zero-crossing pitch, peak and crossing count for verification
gfx_r = 1; gfx_g = 1; gfx_b = 1; gfx_a = 0.9;
gfx_x = 4; gfx_y = 4;
// display a reduced pitch value (scaled down by pitch_scale)
pitch_scale = 0.92; // display = measured * pitch_scale (0.90 = reduce by 10%)
zc_pitch_display = zc_pitch * pitch_scale;
sprintf(#, "zc: %.2f Hz  peak: %.6f  cx: %d", zc_pitch_display, peak_zc, crossings);
gfx_drawstr(#);

scope_h = ((gfx_h-gfx_texth*2-6-4)*0.5)|0;
scope_ycent = gfx_h - scope_h - gfx_texth - 4;

// Feature 2: Normalization for 0dBFS display (always enabled)
norm_factor = 1;
// Find peak in current view
peak = 0;
tmp_rdptr = recpos_u - viewsize_spls*2 - 2;
tmp_rdptr < 0 ? tmp_rdptr += histsize;
i = 0;
loop(viewsize_spls,
  absval = abs(tmp_rdptr[0]);
  absval > peak ? peak = absval;
  absval = abs(tmp_rdptr[1]);
  absval > peak ? peak = absval;
  (tmp_rdptr+=2) >= histsize ? tmp_rdptr=0;
  i += 1;
);
// Compute normalization factor:
// - If we have a peak and normalization is allowed, compute norm_factor=1/peak and store it
// - If normalization is disabled (signal below cutoff), reuse last_norm_factor so the
//   existing scale is held and the waveform can shrink naturally
// - If no peak at all, keep last_norm_factor
peak > 0 ? (
  disable_norm == 0 ? (
    norm_factor = 1/peak;
    last_norm_factor = norm_factor;
  ) : (
    norm_factor = last_norm_factor;
  );
) : (
  norm_factor = last_norm_factor;
);

sc= exp(-view_maxdb*(log(10)/20)) * scope_h * norm_factor;

rdptr = recpos_u - viewsize_spls*2 - 2;
rdptr < 0 ? rdptr += histsize;
view_retrig >= 1.0 ? (
  rdptr2 = recpos - 2;
  rdptr2 < 0 ? rdptr2 += histsize;
  pos = 0;
  ll = rdptr2[0]; lr=rdptr2[1];
  while(
    pos < viewsize_spls ? (
      rdptr2 -= 2;
      rdptr2 < 0 ? rdptr2 += histsize;
      l = rdptr2[0]; r=rdptr2[1];

      ((view_retrig|0)==2 ? ((l>=0) && (ll<0) || ((r>=0) && (lr<0))) :
      (view_retrig|0)==3 ? ((l<=0) && (ll>0) || ((r<=0) && (lr>0))) :
      ((l<0) != (ll<0) || (r<0) != (lr<0))) ? (
        rdptr=rdptr2 + 2 - viewsize_spls*2;
        rdptr < 0 ? rdptr += histsize;
        0;
      ):(lr=r; ll=l; pos+=1; );
    );    
  );
);

rdptr >= histsize ? rdptr -= histsize;
x=0;
viewadv < 1 ? (
 // multiple samples per pixel
  lx=0;
  i=0;
  minl=maxl=rdptr[0]; minr=maxr=rdptr[1];
  (rdptr+=2) >= histsize ? rdptr=0;
  loop(viewsize_spls,
    tx=(x|0);
    tx>lx?(
      minl = min(max(-1,(scope_ycent+0.5-minl*sc)|0),gfx_h+2);
      maxl = min(max(-1,(scope_ycent+0.5-maxl*sc)|0),gfx_h+2);
      minr = min(max(-1,(scope_ycent+0.5-minr*sc)|0),gfx_h+2);
      maxr = min(max(-1,(scope_ycent+0.5-maxr*sc)|0),gfx_h+2);
      
      gfx_a=0.25;
      color1();
      maxl-1 > scope_ycent ? gfx_line(lx,maxl-1,lx,scope_ycent) : 
      minl+1 < scope_ycent ? gfx_line(lx,minl+1,lx,scope_ycent);

      color2();
      maxr-1 > scope_ycent ? gfx_line(lx,maxr-1,lx,scope_ycent) : 
      minr+1 < scope_ycent ? gfx_line(lx,minr+1,lx,scope_ycent);
           
      color1();
      gfx_a=.6;
      gfx_line(lx,minl,lx,maxl);
      color2();
      gfx_line(lx,minr,lx,maxr);

      minl=maxl=rdptr[0]; 
      minr=maxr=rdptr[1];
      lx=tx;
    ) : (
      minl=min(minl,v = rdptr[0]); maxl=max(maxl,v);
      minr=min(minr,v2 = rdptr[1]); maxr=max(maxr,v2);
    );
    (rdptr+=2) >= histsize ? rdptr=0;
    x+=viewadv;
  );
  // last pixel
  minl = min(max(-1,(scope_ycent+0.5-minl*sc)|0),gfx_h+2);
  maxl = min(max(-1,(scope_ycent+0.5-maxl*sc)|0),gfx_h+2);
  minr = min(max(-1,(scope_ycent+0.5-minr*sc)|0),gfx_h+2);
  maxr = min(max(-1,(scope_ycent+0.5-maxr*sc)|0),gfx_h+2);
  color1();
  gfx_a=0.35;
  maxl-1 > scope_ycent ? gfx_line(lx,maxl-1,lx,scope_ycent) : 
  minl+1 < scope_ycent ? gfx_line(lx,minl+1,lx,scope_ycent);

  color2();
  maxr-1 > scope_ycent ? gfx_line(lx,maxr-1,lx,scope_ycent) : 
  minr+1 < scope_ycent ? gfx_line(lx,minr+1,lx,scope_ycent);
      
  gfx_a=.6;
  color1();
  gfx_line(lx,minl,lx,maxl);
  color2();
gfx_line(lx,minr,lx,maxr);  
  
) : ( 
  maxval=scope_h+64;
  // multiple pixels per sample
  i=viewsize_spls&1;
  loop(viewsize_spls,
    x1 = x|0;
    x2 = (x+=viewadv)|0;
    
    viewadv<3 ? (
      color1();
      
      loop(2,
        v = (rdptr[0] * sc)|0;
        
        gfx_a=.25;
        v < 0 ? (
          v < -maxval ? v=-maxval;
          gfx_rect(x1,scope_ycent,x2-x1,-v)
        ) : (
          v > maxval ? v=maxval;
          gfx_rect(x1,scope_ycent-v,x2-x1,v);      
        );
        gfx_a=.6;
        gfx_rect(x1,scope_ycent-v,x2-x1,1);

        rdptr+=1;
        color2();
      );
    
    ) : (
      color1();
      
      loop(2,
        gfx_a=(i&1) ? 0.25:0.125;
        v = (rdptr[0] * sc)|0;
        v < 0 ? (
          v < -maxval ? v=-maxval;
          gfx_rect(x1,scope_ycent,x2-x1,-v) 
        ) : (
          v > maxval ? v=maxval;
          gfx_rect(x1,scope_ycent-v,x2-x1,v);      
        );
        gfx_a=0.6;
        gfx_rect(x1,scope_ycent-v,x2-x1,1);
        rdptr+=1;
        color2();
        i+=1;
      );
      i+=1;
    );
    rdptr >= histsize ? rdptr=0;
  );
)
