version: 1.3
Author: 7thResonance
desc:7R Oscilloscope

--[[
@changelog - FFT based pitch detection. a bit better accuracy.
    - reduced the opacity of the filled colour
    - Smoothed the window change.
@provides [effect] JSFX\7R Oscilloscope.jsfx
@about modded version of the cockos oscilloscope.
    - only normalised mode
    - clean display for docking to master channel
    - Imperfect period tracking to see waveform shape
--]]


in_pin:left input
in_pin:right input
options:no_meter



@init
gfx_ext_flags |= 0x100 | 0x200;
gfx_ext_retina == 0 ? gfx_ext_retina = 1;
ext_nodenorm=1;
recpos=0;
gfx_clear=-1;
g_maxlen_ms=5000;
histsize=((srate*2.0*g_maxlen_ms/1000)|0)*2;

// Initialize smoothing variables
smooth_factor = 1; // Smoothing disabled
prev_left = 0;
prev_right = 0;
last_norm_factor = 1;




// Pitch detection state (FFT-based detector)
zc_period = 0;
zc_pitch = 0;
crossings = 0; // retained for debug compatibility

// smoothing for period display (milliseconds)
smooth_ms = 100; // target smoothing time ~100 ms
smoothed_period = 0;
tau_samples = smooth_ms * 0.001 * srate;
alpha_sample = 1 - exp(-1.0 / tau_samples);

// Basic FFT-based pitch detection setup (simple max-bin detector)
// We'll use a fixed FFT size (power of two) and a Hann window.
// Requested 8096 -> use nearest power-of-two 8192 for FFT implementation
fft_size = 8192;
// Ensure fft_size is at least the zc_bufsize for similar resolution
fft_size < zc_bufsize ? (fft_size = 1 << (floor(log(zc_bufsize)/log(2))+1));
// prepare buffers in a fixed memory area well after history buffers to avoid collisions
static_base = histsize*2 + 1024;
fft_in = static_base; // input buffer (filled in @sample)
fft_pos = 0; // write position
fftworkspace = fft_in + fft_size + 16; // workspace area
window = fftworkspace + fft_size + 16;
// generate Hann window
i=0; dwindowpos = $pi*2/fft_size;
loop(fft_size,
  window[i] = 0.5 - 0.5 * cos(i * dwindowpos);
  i += 1;
);

// UI defaults: retrig ascending, range auto, length auto
view_retrig = 2; // ascending
view_maxdb = 0; // auto range (0dB)
view_msec = 0; // auto length (period-locked)

@block 
g_last_wr = time_precise();


@sample
// No sample cutting: write raw faded values equal to the samples (no hard suppression)
// Keep prev_* in sync but do not force samples to zero
fade_left = spl0;
fade_right = spl1;
prev_left = fade_left;
prev_right = fade_right;
// Optionally disable auto-normalisation when the raw audio is very small (e.g. -90 dB):
// if the raw channel level is below disable_lin, write the raw sum into the scope buffer
// and let the waveform shrink naturally; otherwise use the faded/gated values.
disable_db = -55; // dB threshold below which auto-normalise is disabled
disable_lin = exp(disable_db*(log(10)/20));
// compute the raw channel magnitude to decide whether to hold normalization
raw_max = abs(spl0) > abs(spl1) ? abs(spl0) : abs(spl1);
disable_norm = raw_max < disable_lin ? 1 : 0;
// Feature 1: Sum L+R for display using faded values (does not affect audio output)
// Use the fade_* values so the gate/expander actually suppresses tiny residuals in the scope
sum = (fade_left + fade_right) * 0.5;
recpos[0]=sum;
recpos[1]=sum;
recpos = (recpos+2) >= histsize ? 0 : (recpos+2);

// update smoothed period every sample so smoothing time constant is accurate
smoothed_period += alpha_sample * (zc_period - smoothed_period);


// --- Basic FFT bin pitch detection (replaces zero-crossing) ---
// Fill the FFT input buffer with the summed signal; run FFT when full and pick the
// bin with the largest magnitude within 40..5000 Hz, set zc_pitch to that freq.
fft_in[fft_pos] = sum;
fft_pos += 1;

fft_pos >= fft_size ? (
  fft_pos = 0;
  // apply window and copy to workspace
  i = 0; buf = fftworkspace;
  loop(fft_size,
    buf[] = fft_in[i] * window[i];
    i += 1; buf += 1;
  );

  // perform real FFT
  fft_real(fftworkspace, fft_size);
  fft_permute(fftworkspace, fft_size/2);

  // find max magnitude bin in desired range (minFreq..Nyquist)
  minFreq = 40;
  minBin = floor(minFreq * fft_size / srate);
  // scan up to Nyquist (half FFT)
  maxBin = (fft_size/2 - 1);
  bestBin = minBin;
  bestMag = 0;
  buf = fftworkspace + 0;
  // bin 0 is DC (real at buf[0]), bin k complex is (buf[2*k], buf[2*k+1])
  // iterate bins using loop to avoid parser issues with while constructs
  binCount = maxBin - minBin + 1;
  i = 0;
  loop(binCount,
    idx = minBin + i;
    real = fftworkspace[2*idx];
    imag = fftworkspace[2*idx+1];
    mag = sqr(real) + sqr(imag);
    mag > bestMag ? ( bestMag = mag; bestBin = idx; );
    i += 1;
  );

  // parabolic interpolation around the best bin for sub-bin accuracy
  // only interpolate if bestBin is not at the search edges
  bestBin > minBin && bestBin < maxBin ? (
    // magnitudes (power) at bins b-1, b, b+1
    r1 = fftworkspace[2*(bestBin-1)]; i1 = fftworkspace[2*(bestBin-1)+1]; m1 = sqr(r1) + sqr(i1);
    r2 = fftworkspace[2*bestBin];     i2 = fftworkspace[2*bestBin+1];     m2 = sqr(r2) + sqr(i2);
    r3 = fftworkspace[2*(bestBin+1)]; i3 = fftworkspace[2*(bestBin+1)+1]; m3 = sqr(r3) + sqr(i3);
    denom = (m1 - 2*m2 + m3);
    denom == 0 ? ( delta = 0 ) : ( delta = 0.5 * (m1 - m3) / denom );
    refinedBin = bestBin + delta;
    zc_pitch = refinedBin * srate / fft_size;
    zc_period = zc_pitch > 0 ? srate / zc_pitch : 0;
  ) : (
    bestBin > 0 ? (
      zc_pitch = bestBin * srate / fft_size;
      zc_period = zc_pitch > 0 ? srate / zc_pitch : 0;
    ) : (
      zc_pitch = 0;
      zc_period = 0;
    )
  );
  // keep a small indicator of peak size for debug similar to old code
  peak_zc = sqrt(bestMag);
  crossings = 0; // not used in FFT method, keep defined for debug string
);


@gfx 640 400
small_mode = gfx_w<200*gfx_ext_retina || gfx_h<100*gfx_ext_retina;
gfx_ext_retina>1 ? gfx_setfont(1,"Arial",16*gfx_ext_retina,'b') : gfx_setfont(0);

gfx_getchar(); // request mouse_cap to be set even when mouse button not down



// --- Use detected period for auto window (display follows detected pitch) ---
smoothed_period > 0 ? (
  view_msec = smoothed_period*1000/srate;
) : (
  view_msec = 100; // fallback default
);
viewsize_spls = (view_msec*srate*0.001)|0;

function color1() ( gfx_r=0; gfx_g=0; gfx_b=1.0; );
function color2() ( gfx_r=0; gfx_g=0; gfx_b=1.0; );


function format_time_msec(a) (
  abs(a) < 1000 ? 
    sprintf(#,"%.02fms",a + 0.005) : 
    sprintf(#,"%.02fs",a*0.001 + 0.005);
);

function format_time_msec_hz(b)(
  b > 1 ? 
    b > 250 ? 
      sprintf(#,small_mode ? "%.1fs":"%.02fs",b*0.001 + 0.005) : 
    sprintf(#,small_mode ? "%dHz":"%d Hz",1000/b+0.5) : 
  sprintf(#,small_mode?"%.1fk":"%.1f kHz",1/b + 0.05); 
); 

// All mouse wheel and slider automation code removed for static UI

rdoffs = view_retrig >= 1.0 ? 0 : max(0,max(srate*1/20, samplesblock*2) - (time_precise() - g_last_wr)*srate)|0;
recpos_u = recpos - rdoffs*2;
recpos_u < 0 ? recpos_u += histsize;


view_msec_rounded = view_msec;
viewsize_spls = (view_msec*srate*0.001)|0;
viewadv = gfx_w/viewsize_spls;
// when zoomed out, adjust interval so that each peak represents a discrete number of samples
viewadvn = floor(1/viewadv + 0.5);
viewadvn > 8 ? (
  viewsize_spls = viewadvn * gfx_w;
  viewadv = 1/viewadvn;
  view_msec_rounded = viewsize_spls*1000/srate;
  recpos_u = floor(recpos_u/(viewadvn*2))*viewadvn*2;
) : viewadvn=0;

// always update view
view_maxdb_last = view_maxdb;
recpos_u_last = recpos_u;
old_w=gfx_w; old_h=gfx_h;

// Clamp view_maxdb to [-60, 0] dB range
view_maxdb < -60 ? view_maxdb = -60;
view_maxdb > 0 ? view_maxdb = 0;

gfx_r=gfx_g=gfx_b=0; gfx_a=1;
gfx_x=gfx_y=0;
gfx_rectto(gfx_w,gfx_h);

// Debug overlay: show zero-crossing pitch, peak and crossing count for verification
gfx_r = 1; gfx_g = 1; gfx_b = 1; gfx_a = 0.9;
gfx_x = 4; gfx_y = 4;
// display detected pitch directly
sprintf(#, "fft: %.2f Hz  peak: %.6f", zc_pitch, peak_zc);
gfx_drawstr(#);

scope_h = ((gfx_h-gfx_texth*2-6-4)*0.5)|0;
scope_ycent = gfx_h - scope_h - gfx_texth - 4;

// Feature 2: Normalization for 0dBFS display (always enabled)
norm_factor = 1;
// Find peak in current view
peak = 0;
tmp_rdptr = recpos_u - viewsize_spls*2 - 2;
tmp_rdptr < 0 ? tmp_rdptr += histsize;
i = 0;
loop(viewsize_spls,
  absval = abs(tmp_rdptr[0]);
  absval > peak ? peak = absval;
  absval = abs(tmp_rdptr[1]);
  absval > peak ? peak = absval;
  (tmp_rdptr+=2) >= histsize ? tmp_rdptr=0;
  i += 1;
);
// Compute normalization factor:
// - If we have a peak and normalization is allowed, compute norm_factor=1/peak and store it
// - If normalization is disabled (signal below cutoff), reuse last_norm_factor so the
//   existing scale is held and the waveform can shrink naturally
// - If no peak at all, keep last_norm_factor
peak > 0 ? (
  disable_norm == 0 ? (
    norm_factor = 1/peak;
    last_norm_factor = norm_factor;
  ) : (
    norm_factor = last_norm_factor;
  );
) : (
  norm_factor = last_norm_factor;
);

sc= exp(-view_maxdb*(log(10)/20)) * scope_h * norm_factor;

rdptr = recpos_u - viewsize_spls*2 - 2;
rdptr < 0 ? rdptr += histsize;
view_retrig >= 1.0 ? (
  rdptr2 = recpos - 2;
  rdptr2 < 0 ? rdptr2 += histsize;
  pos = 0;
  ll = rdptr2[0]; lr=rdptr2[1];
  while(
    pos < viewsize_spls ? (
      rdptr2 -= 2;
      rdptr2 < 0 ? rdptr2 += histsize;
      l = rdptr2[0]; r=rdptr2[1];

      ((view_retrig|0)==2 ? ((l>=0) && (ll<0) || ((r>=0) && (lr<0))) :
      (view_retrig|0)==3 ? ((l<=0) && (ll>0) || ((r<=0) && (lr>0))) :
      ((l<0) != (ll<0) || (r<0) != (lr<0))) ? (
        rdptr=rdptr2 + 2 - viewsize_spls*2;
        rdptr < 0 ? rdptr += histsize;
        0;
      ):(lr=r; ll=l; pos+=1; );
    );    
  );
);

rdptr >= histsize ? rdptr -= histsize;
x=0;
viewadv < 1 ? (
 // multiple samples per pixel
  lx=0;
  i=0;
  minl=maxl=rdptr[0]; minr=maxr=rdptr[1];
  (rdptr+=2) >= histsize ? rdptr=0;
  loop(viewsize_spls,
    tx=(x|0);
    tx>lx?(
      minl = min(max(-1,(scope_ycent+0.5-minl*sc)|0),gfx_h+2);
      maxl = min(max(-1,(scope_ycent+0.5-maxl*sc)|0),gfx_h+2);
      minr = min(max(-1,(scope_ycent+0.5-minr*sc)|0),gfx_h+2);
      maxr = min(max(-1,(scope_ycent+0.5-maxr*sc)|0),gfx_h+2);
      
  gfx_a=0.10;
      color1();
      maxl-1 > scope_ycent ? gfx_line(lx,maxl-1,lx,scope_ycent) : 
      minl+1 < scope_ycent ? gfx_line(lx,minl+1,lx,scope_ycent);

      color2();
      maxr-1 > scope_ycent ? gfx_line(lx,maxr-1,lx,scope_ycent) : 
      minr+1 < scope_ycent ? gfx_line(lx,minr+1,lx,scope_ycent);
           
      color1();
      gfx_a=.6;
      gfx_line(lx,minl,lx,maxl);
      color2();
      gfx_line(lx,minr,lx,maxr);

      minl=maxl=rdptr[0]; 
      minr=maxr=rdptr[1];
      lx=tx;
    ) : (
      minl=min(minl,v = rdptr[0]); maxl=max(maxl,v);
      minr=min(minr,v2 = rdptr[1]); maxr=max(maxr,v2);
    );
    (rdptr+=2) >= histsize ? rdptr=0;
    x+=viewadv;
  );
  // last pixel
  minl = min(max(-1,(scope_ycent+0.5-minl*sc)|0),gfx_h+2);
  maxl = min(max(-1,(scope_ycent+0.5-maxl*sc)|0),gfx_h+2);
  minr = min(max(-1,(scope_ycent+0.5-minr*sc)|0),gfx_h+2);
  maxr = min(max(-1,(scope_ycent+0.5-maxr*sc)|0),gfx_h+2);
  color1();
  gfx_a=0.10;
  maxl-1 > scope_ycent ? gfx_line(lx,maxl-1,lx,scope_ycent) : 
  minl+1 < scope_ycent ? gfx_line(lx,minl+1,lx,scope_ycent);

  color2();
  maxr-1 > scope_ycent ? gfx_line(lx,maxr-1,lx,scope_ycent) : 
  minr+1 < scope_ycent ? gfx_line(lx,minr+1,lx,scope_ycent);
      
  gfx_a=.6;
  color1();
  gfx_line(lx,minl,lx,maxl);
  color2();
gfx_line(lx,minr,lx,maxr);  
  
) : ( 
  maxval=scope_h+64;
  // multiple pixels per sample
  i=viewsize_spls&1;
  loop(viewsize_spls,
    x1 = x|0;
    x2 = (x+=viewadv)|0;
    
    viewadv<3 ? (
      color1();
      
      loop(2,
        v = (rdptr[0] * sc)|0;
        
  gfx_a=0.10;
        v < 0 ? (
          v < -maxval ? v=-maxval;
          gfx_rect(x1,scope_ycent,x2-x1,-v)
        ) : (
          v > maxval ? v=maxval;
          gfx_rect(x1,scope_ycent-v,x2-x1,v);      
        );
        gfx_a=.6;
        gfx_rect(x1,scope_ycent-v,x2-x1,1);

        rdptr+=1;
        color2();
      );
    
    ) : (
      color1();
      
      loop(2,
  gfx_a=0.10;
        v = (rdptr[0] * sc)|0;
        v < 0 ? (
          v < -maxval ? v=-maxval;
          gfx_rect(x1,scope_ycent,x2-x1,-v) 
        ) : (
          v > maxval ? v=maxval;
          gfx_rect(x1,scope_ycent-v,x2-x1,v);      
        );
        gfx_a=0.6;
        gfx_rect(x1,scope_ycent-v,x2-x1,1);
        rdptr+=1;
        color2();
        i+=1;
      );
      i+=1;
    );
    rdptr >= histsize ? rdptr=0;
  );
)